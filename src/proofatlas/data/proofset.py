"""ProofSet for managing collections of proofs for training."""

from pathlib import Path
from typing import List, Optional, Dict, Any, Tuple
import torch
from torch.utils.data import Dataset

from proofatlas.proofs import Proof
from proofatlas.proofs.state import ProofState
from proofatlas.core.logic import Problem, Clause
from proofatlas.loops.base import Loop
from proofatlas.loops.registry import get_loop
from proofatlas.selectors.base import Selector
from proofatlas.selectors.registry import get_selector
from .problemset import Problemset


class Proofset(Dataset):
    """Dataset of proofs generated by running a selector with a loop."""
    
    def __init__(self, 
                 name: str,
                 problemset: Optional[Problemset] = None,
                 loop: Optional[Loop] = None,
                 selector: Optional[Selector] = None,
                 max_steps: int = 100,
                 cache_dir: Optional[Path] = None):
        """
        Initialize a ProofSet.
        
        Args:
            name: Name of the proof set
            problemset: ProblemSet to generate proofs from
            loop: Loop to use for proof generation
            selector: Selector to use for clause selection
            max_steps: Maximum steps per proof attempt
            cache_dir: Directory to cache generated proofs
        """
        self.name = name
        self.problemset = problemset
        self.loop = loop
        self.selector = selector
        self.max_steps = max_steps
        self.cache_dir = cache_dir
        
        # Storage for proofs
        self.proofs: List[Proof] = []
        self.problem_indices: List[int] = []
        
    
    def create(self, problemset: Problemset, loop: Loop, selector: Selector, 
               steps: Optional[int] = None):
        """
        Generate proofs by running the selector on the problemset.
        
        Args:
            problemset: Problems to solve
            loop: Loop to use
            selector: Selector to use
            steps: Max steps (overrides self.max_steps if provided)
        """
        self.problemset = problemset
        self.loop = loop
        self.selector = selector
        if steps is not None:
            self.max_steps = steps
        
        # Clear existing data
        self.proofs.clear()
        self.problem_indices.clear()
        
        # Generate proofs for each problem
        for prob_idx in range(len(problemset)):
            problem = problemset.get_problem(prob_idx)
            proof = self._generate_proof(problem)
            
            if proof is not None and proof.length > 0:
                self.proofs.append(proof)
                self.problem_indices.append(prob_idx)
    
    def _generate_proof(self, problem: Problem) -> Optional[Proof]:
        """Generate a proof for a single problem."""
        # Initialize proof with problem clauses
        initial_state = ProofState(
            processed=[],
            unprocessed=list(problem.clauses)
        )
        proof = Proof(initial_state)
        
        # Run selector with loop
        try:
            proof = self.selector.run(proof, self.loop, steps=self.max_steps)
        except Exception as e:
            print(f"Error generating proof: {e}")
            return None
        
        return proof
    
    def __len__(self) -> int:
        """Number of proofs in the dataset."""
        return len(self.proofs)
    
    def __getitem__(self, idx: int) -> Tuple[Proof, Dict[str, Any]]:
        """
        Get proof and metadata.
        
        Returns:
            Tuple of:
                - Proof object
                - Metadata dict
        """
        proof = self.proofs[idx]
        problem_idx = self.problem_indices[idx]
        
        metadata = {
            'proof_length': proof.length,
            'problem_idx': problem_idx,
            'is_complete': proof.is_complete,
            'problem_name': self.problemset.problem_files[problem_idx].stem if self.problemset else f"problem_{problem_idx}"
        }
        
        return proof, metadata
    
    def save(self, path: Path):
        """Save the proof set to disk."""
        data = {
            'name': self.name,
            'proofs': self.proofs,
            'problem_indices': self.problem_indices,
            'max_steps': self.max_steps,
            'loop_name': self.loop.__class__.__name__ if self.loop else None,
            'selector_name': self.selector.__class__.__name__ if self.selector else None,
        }
        torch.save(data, path)
    
    def load(self, path: Path):
        """Load a proof set from disk."""
        data = torch.load(path)
        self.name = data['name']
        self.proofs = data['proofs']
        self.problem_indices = data['problem_indices']
        self.max_steps = data['max_steps']
        self._encoded_cache.clear()