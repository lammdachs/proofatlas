"""ProofSet for managing collections of proofs for training."""

from pathlib import Path
from typing import List, Optional, Dict, Any, Tuple
import torch
from torch.utils.data import Dataset

from proofatlas.core.proof import Proof
from proofatlas.core.state import ProofState
from proofatlas.core.logic import Problem, Clause
from proofatlas.loops.base import Loop
from proofatlas.loops.registry import get_loop
from proofatlas.selectors.base import Selector
from proofatlas.selectors.registry import get_selector
from proofatlas.dataformats import get_data_format
from .problemset import Problemset


class Proofset(Dataset):
    """Dataset of proofs generated by running a selector with a loop."""
    
    def __init__(self, 
                 name: str,
                 problemset: Optional[Problemset] = None,
                 loop: Optional[Loop] = None,
                 selector: Optional[Selector] = None,
                 data_format: str = 'graph',
                 max_steps: int = 100,
                 cache_dir: Optional[Path] = None):
        """
        Initialize a ProofSet.
        
        Args:
            name: Name of the proof set
            problemset: ProblemSet to generate proofs from
            loop: Loop to use for proof generation
            selector: Selector to use for clause selection
            data_format: Format for encoding proof states
            max_steps: Maximum steps per proof attempt
            cache_dir: Directory to cache generated proofs
        """
        self.name = name
        self.problemset = problemset
        self.loop = loop
        self.selector = selector
        self.max_steps = max_steps
        self.cache_dir = cache_dir
        
        # Data format for encoding
        self.data_format = get_data_format(data_format)
        
        # Storage for proofs
        self.proofs: List[Proof] = []
        self.problem_indices: List[int] = []
        
        # Cache for encoded data
        self._encoded_cache: Dict[int, Any] = {}
    
    def create(self, problemset: Problemset, loop: Loop, selector: Selector, 
               steps: Optional[int] = None):
        """
        Generate proofs by running the selector on the problemset.
        
        Args:
            problemset: Problems to solve
            loop: Loop to use
            selector: Selector to use
            steps: Max steps (overrides self.max_steps if provided)
        """
        self.problemset = problemset
        self.loop = loop
        self.selector = selector
        if steps is not None:
            self.max_steps = steps
        
        # Clear existing data
        self.proofs.clear()
        self.problem_indices.clear()
        self._encoded_cache.clear()
        
        # Generate proofs for each problem
        for prob_idx in range(len(problemset)):
            problem = problemset.get_problem(prob_idx)
            proof = self._generate_proof(problem)
            
            if proof is not None and proof.length > 0:
                self.proofs.append(proof)
                self.problem_indices.append(prob_idx)
    
    def _generate_proof(self, problem: Problem) -> Optional[Proof]:
        """Generate a proof for a single problem."""
        # Initialize proof with problem clauses
        initial_state = ProofState(
            processed=[],
            unprocessed=list(problem.clauses)
        )
        proof = Proof(initial_state)
        
        # Run selector with loop
        try:
            proof = self.selector.run(proof, self.loop, steps=self.max_steps)
        except Exception as e:
            print(f"Error generating proof: {e}")
            return None
        
        return proof
    
    def __len__(self) -> int:
        """Number of proofs in the dataset."""
        return len(self.proofs)
    
    def __getitem__(self, idx: int) -> Tuple[List[Any], List[int], Dict[str, Any]]:
        """
        Get encoded proof data for training.
        
        Returns:
            Tuple of:
                - List of encoded states
                - List of selected clause indices
                - Metadata dict
        """
        if idx in self._encoded_cache:
            return self._encoded_cache[idx]
        
        proof = self.proofs[idx]
        
        # Encode each state in the proof
        encoded_states = []
        selected_clauses = []
        
        for i, step in enumerate(proof.steps[:-1]):  # Exclude last step
            # Encode the state
            encoded = self.data_format.encode_state(step.state)
            encoded_states.append(encoded)
            
            # Get the selected clause from next step
            next_step = proof.steps[i + 1]
            if next_step.selected_clause is not None:
                selected_clauses.append(next_step.selected_clause)
            else:
                selected_clauses.append(-1)  # No selection
        
        metadata = {
            'proof_length': proof.length,
            'problem_idx': self.problem_indices[idx],
            'is_complete': proof.is_complete,
            'problem_name': self.problemset.problem_files[self.problem_indices[idx]].stem
        }
        
        result = (encoded_states, selected_clauses, metadata)
        self._encoded_cache[idx] = result
        
        return result
    
    def save(self, path: Path):
        """Save the proof set to disk."""
        data = {
            'name': self.name,
            'proofs': self.proofs,
            'problem_indices': self.problem_indices,
            'max_steps': self.max_steps,
            'loop_name': self.loop.__class__.__name__ if self.loop else None,
            'selector_name': self.selector.__class__.__name__ if self.selector else None,
        }
        torch.save(data, path)
    
    def load(self, path: Path):
        """Load a proof set from disk."""
        data = torch.load(path)
        self.name = data['name']
        self.proofs = data['proofs']
        self.problem_indices = data['problem_indices']
        self.max_steps = data['max_steps']
        self._encoded_cache.clear()