<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProofAtlas - Documentation</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="docs-style.css">
</head>
<body>
    <div class="container">
        <header>
            <div style="display: flex; align-items: center; justify-content: center; gap: 15px;">
                <img src="favicon.svg" alt="ProofAtlas" style="width: 48px; height: 48px;">
                <h1>ProofAtlas</h1>
            </div>
            <p>Documentation</p>
            <nav class="doc-nav">
                <a href="./index.html">← Back to Prover</a>
            </nav>
        </header>

        <main class="docs-main">
            <div class="docs-sidebar">
                <h3>Contents</h3>
                <ul>
                    <li><a href="#overview">Overview</a></li>
                    <li><a href="#saturation">Saturation-Based Proving</a></li>
                    <li><a href="#calculus">Inference Calculus</a></li>
                    <li><a href="#selection">Literal Selection</a></li>
                    <li><a href="#simplification">Simplification Rules</a></li>
                    <li><a href="#ml">Machine Learning</a></li>
                    <li><a href="#examples">Examples</a></li>
                </ul>
            </div>

            <div class="docs-content">
                <section id="overview">
                    <h2>Overview</h2>
                    <p>
                        ProofAtlas is a <strong>saturation-based theorem prover</strong> for first-order logic with equality.
                        It implements the superposition calculus, a complete inference system for equational reasoning.
                    </p>
                    <p>
                        The prover runs entirely in your browser using WebAssembly, providing a fast and private
                        proof search experience without any server-side computation.
                    </p>

                    <h3>Key Features</h3>
                    <ul>
                        <li>Complete superposition calculus for equality reasoning</li>
                        <li>Multiple literal selection strategies</li>
                        <li>Clause subsumption and simplification</li>
                        <li>Knuth-Bendix Ordering (KBO) for term ordering</li>
                        <li>Interactive proof inspection</li>
                    </ul>
                </section>

                <section id="saturation">
                    <h2>Saturation-Based Proving</h2>
                    <p>
                        The prover uses a <strong>given clause algorithm</strong> to systematically explore the
                        search space:
                    </p>

                    <div class="algorithm-box">
                        <h4>Given Clause Loop</h4>
                        <ol>
                            <li>Start with initial clauses from the problem (negated conjecture + axioms)</li>
                            <li>Maintain two sets:
                                <ul>
                                    <li><strong>Processed</strong>: Clauses already used for inference</li>
                                    <li><strong>Unprocessed</strong>: Clauses waiting to be processed</li>
                                </ul>
                            </li>
                            <li>Repeat until proof found or resources exhausted:
                                <ul>
                                    <li>Select a <em>given clause</em> from unprocessed</li>
                                    <li>Apply all inference rules between given clause and processed clauses</li>
                                    <li>Simplify and filter new clauses</li>
                                    <li>Check if empty clause (⊥) derived → <strong>Proof found!</strong></li>
                                    <li>Move given clause to processed set</li>
                                </ul>
                            </li>
                        </ol>
                    </div>

                    <p class="note">
                        <strong>Note:</strong> The empty clause ⊥ represents a contradiction, proving that the
                        original formula is unsatisfiable (and thus the conjecture is a theorem).
                    </p>
                </section>

                <section id="calculus">
                    <h2>Inference Calculus</h2>
                    <p>
                        ProofAtlas implements the following inference rules:
                    </p>

                    <div class="inference-rule">
                        <h3>Binary Resolution</h3>
                        <div class="rule-formula">
                            <div class="premise">C ∨ L</div>
                            <div class="premise">D ∨ ¬L'</div>
                            <div class="conclusion">(C ∨ D)σ</div>
                        </div>
                        <p>where σ = mgu(L, L') is the most general unifier</p>
                        <p class="rule-description">
                            Combines two clauses by resolving complementary literals.
                        </p>
                    </div>

                    <div class="inference-rule">
                        <h3>Factoring</h3>
                        <div class="rule-formula">
                            <div class="premise">C ∨ L ∨ L'</div>
                            <div class="conclusion">(C ∨ L)σ</div>
                        </div>
                        <p>where σ = mgu(L, L')</p>
                        <p class="rule-description">
                            Merges two identical literals in a clause.
                        </p>
                    </div>

                    <div class="inference-rule">
                        <h3>Superposition</h3>
                        <div class="rule-formula">
                            <div class="premise">C ∨ l ≈ r</div>
                            <div class="premise">D ∨ s[u] ≈ t</div>
                            <div class="conclusion">(C ∨ D ∨ s[r] ≈ t)σ</div>
                        </div>
                        <p>where σ = mgu(l, u), and ordering constraints apply</p>
                        <p class="rule-description">
                            Replaces a subterm in an equality using another equality. This is the key rule
                            for equational reasoning.
                        </p>
                        <div class="constraints">
                            <strong>Constraints:</strong>
                            <ul>
                                <li>l ≈ r must be a positive equality</li>
                                <li>lσ ≻ rσ (l is maximal in the equation)</li>
                                <li>l ≈ r is selected in C ∨ l ≈ r</li>
                            </ul>
                        </div>
                    </div>

                    <div class="inference-rule">
                        <h3>Equality Resolution</h3>
                        <div class="rule-formula">
                            <div class="premise">C ∨ ¬(s ≈ t)</div>
                            <div class="conclusion">Cσ</div>
                        </div>
                        <p>where σ = mgu(s, t)</p>
                        <p class="rule-description">
                            Removes reflexive negative equalities (e.g., ¬(X ≈ X) is always false).
                        </p>
                    </div>

                    <div class="inference-rule">
                        <h3>Equality Factoring</h3>
                        <div class="rule-formula">
                            <div class="premise">C ∨ s ≈ t ∨ u ≈ v</div>
                            <div class="conclusion">(C ∨ s ≈ t ∨ ¬(t ≈ v))σ</div>
                        </div>
                        <p>where σ = mgu(s, u) and sσ ≻ tσ, uσ ≻ vσ</p>
                        <p class="rule-description">
                            Special factoring rule for equalities that maintains ordering constraints.
                        </p>
                    </div>
                </section>

                <section id="selection">
                    <h2>Literal Selection Strategies</h2>
                    <p>
                        Literal selection determines which literals in a clause are eligible for inference.
                        Based on <a href="https://link.springer.com/chapter/10.1007/978-3-319-40229-1_21">Hoder et al. "Selecting the selection" (2016)</a>,
                        ProofAtlas supports four strategies matching Vampire's numbering:
                    </p>

                    <div class="strategy-box">
                        <h3>Selection 0: Select All</h3>
                        <p>All literals are selected for inference.</p>
                        <p class="strategy-note">
                            <strong>Use case:</strong> Maximum inference potential, guarantees completeness but can generate many clauses.
                        </p>
                    </div>

                    <div class="strategy-box">
                        <h3>Selection 20: Select Maximal</h3>
                        <p>Selects all maximal literals based on Knuth-Bendix Ordering (KBO).</p>
                        <p class="strategy-note">
                            <strong>Use case:</strong> Focuses on "heavy" literals that might be easier to resolve.
                        </p>
                    </div>

                    <div class="strategy-box">
                        <h3>Selection 21: Unique Maximal</h3>
                        <p>
                            Selects the unique maximal literal if one exists.
                            Otherwise, selects max-weight negative literal if one exists.
                            Otherwise, selects all maximal literals.
                        </p>
                        <p class="strategy-note">
                            <strong>Use case:</strong> Good balance between restriction and completeness.
                        </p>
                    </div>

                    <div class="strategy-box">
                        <h3>Selection 22: Neg Max-Weight</h3>
                        <p>
                            Selects the max-weight negative literal if one exists.
                            Otherwise, selects all maximal literals.
                        </p>
                        <p class="strategy-note">
                            <strong>Use case:</strong> Prioritizes eliminating negative literals, which often
                            leads to more efficient proof search.
                        </p>
                    </div>

                    <h3>Impact on Performance</h3>
                    <p>
                        The choice of literal selection strategy significantly affects which inferences are performed:
                    </p>
                    <ul>
                        <li><strong>Selection 0</strong>: Generates the most inferences, exploring the search space broadly</li>
                        <li><strong>Selection 20</strong>: Focuses on maximal literals, reducing the number of inferences</li>
                        <li><strong>Selection 21</strong>: Best single-literal restriction when possible, with fallbacks</li>
                        <li><strong>Selection 22</strong>: Prioritizes negative literals when available</li>
                    </ul>
                    <p class="note">
                        <strong>Note:</strong> No single strategy is universally best. Performance varies significantly
                        depending on problem structure, and the optimal choice is often problem-specific.
                    </p>
                </section>

                <section id="simplification">
                    <h2>Simplification Rules</h2>
                    <p>
                        ProofAtlas uses several simplification techniques to keep the search space manageable:
                    </p>

                    <div class="simplification-box">
                        <h3>Subsumption</h3>
                        <p>
                            A clause C <em>subsumes</em> clause D if there exists a substitution σ such that
                            Cσ ⊆ D. The subsumed clause D can be removed.
                        </p>
                        <p class="example">
                            <strong>Example:</strong> <code>P(X)</code> subsumes <code>P(a) ∨ Q(b)</code>
                        </p>
                        <ul>
                            <li><strong>Forward subsumption:</strong> New clause subsumed by existing clause → discard</li>
                            <li><strong>Backward subsumption:</strong> New clause subsumes existing clauses → remove old clauses</li>
                        </ul>
                    </div>

                    <div class="simplification-box">
                        <h3>Demodulation</h3>
                        <p>
                            Rewrites clauses using unit equalities to create simpler clauses.
                        </p>
                        <p class="example">
                            <strong>Example:</strong> Using <code>f(X) ≈ X</code>, rewrite
                            <code>g(f(a)) ≈ b</code> to <code>g(a) ≈ b</code>
                        </p>
                        <div class="constraints">
                            <strong>Requirements:</strong>
                            <ul>
                                <li>Rewrite rule must be a unit equality</li>
                                <li>One-way matching only (only variables in rewrite rule can be substituted)</li>
                                <li>Ordering constraint: lσ ≻ rσ</li>
                            </ul>
                        </div>
                    </div>

                    <div class="simplification-box">
                        <h3>Tautology Deletion</h3>
                        <p>
                            Clauses that are always true (e.g., <code>P(X) ∨ ¬P(X)</code>) are removed.
                        </p>
                    </div>
                </section>

                <section id="ml">
                    <h2>Machine Learning for Clause Selection</h2>
                    <p>
                        ProofAtlas explores using <strong>graph neural networks</strong> to learn clause selection
                        strategies. Instead of hand-crafted heuristics, we train models to predict which clauses
                        are likely to be useful for finding a proof.
                    </p>

                    <h3>Research Question</h3>
                    <p>
                        <em>How can we best represent logical clauses as graphs and learn to select useful
                        clauses during proof search?</em>
                    </p>

                    <div class="algorithm-box">
                        <h4>Training Pipeline</h4>
                        <ol>
                            <li><strong>Trace Collection:</strong> Run the prover on TPTP problems, recording which clauses were used in successful proofs</li>
                            <li><strong>Graph Construction:</strong> Convert each clause to a tree-structured graph</li>
                            <li><strong>Labeling:</strong> Mark clauses in the proof DAG as positive (+1), others as negative (0)</li>
                            <li><strong>Training:</strong> Train a GNN to score positive clauses higher than negatives</li>
                            <li><strong>Inference:</strong> Use the trained model to guide clause selection during proof search</li>
                        </ol>
                    </div>

                    <h3>Graph Representation</h3>
                    <p>
                        Each clause is converted to a <strong>tree-structured graph</strong> where nodes represent
                        syntactic elements and edges represent parent-child relationships.
                    </p>

                    <div class="strategy-box">
                        <h4>Node Types</h4>
                        <table class="feature-table" style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                            <tr>
                                <th style="text-align: left; padding: 8px; border-bottom: 1px solid #dee2e6;">Type</th>
                                <th style="text-align: left; padding: 8px; border-bottom: 1px solid #dee2e6;">Description</th>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>clause</code></td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Root node for each clause</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>literal</code></td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Positive or negative atom</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>predicate</code></td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Predicate symbol (e.g., P, Q, =)</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>function</code></td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Function application (e.g., f(x))</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;"><code>variable</code></td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Logic variable (e.g., X, Y)</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px;"><code>constant</code></td>
                                <td style="padding: 8px;">Constant symbol (e.g., a, b, e)</td>
                            </tr>
                        </table>
                    </div>

                    <div class="strategy-box">
                        <h4>Node Features (13 dimensions)</h4>
                        <table class="feature-table" style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                            <tr>
                                <th style="text-align: left; padding: 8px; border-bottom: 1px solid #dee2e6;">Dims</th>
                                <th style="text-align: left; padding: 8px; border-bottom: 1px solid #dee2e6;">Feature</th>
                                <th style="text-align: left; padding: 8px; border-bottom: 1px solid #dee2e6;">Description</th>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">0-5</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Node type</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">One-hot encoding of node type</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">6</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Arity</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Number of arguments</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">7</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Arg position</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Position in parent's argument list</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">8</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Depth</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Distance from clause root</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">9</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Age</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Clause age (normalized)</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">10</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Role</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">axiom / hypothesis / negated_conjecture / derived</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">11</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Polarity</td>
                                <td style="padding: 8px; border-bottom: 1px solid #eee;">Positive (+1) or negative (0)</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px;">12</td>
                                <td style="padding: 8px;">Is equality</td>
                                <td style="padding: 8px;">Whether predicate is equality (=)</td>
                            </tr>
                        </table>
                    </div>

                    <div class="example-box">
                        <h4>Example: Graph for <code>P(X, a) ∨ ¬Q(f(Y))</code></h4>
                        <pre style="font-family: monospace; line-height: 1.6;">
clause
├── literal (polarity=+)
│   └── predicate "P"
│       ├── variable "X"
│       └── constant "a"
└── literal (polarity=-)
    └── predicate "Q"
        └── function "f"
            └── variable "Y"</pre>
                        <p style="margin-top: 10px; color: #7f8c8d;">
                            Edges are bidirectional, allowing message passing in both directions during GNN computation.
                        </p>
                    </div>

                    <h3>Model Architectures</h3>

                    <div class="inference-rule">
                        <h4>Graph Convolutional Network (GCN)</h4>
                        <p>
                            The default architecture uses a multi-layer GCN to learn node embeddings:
                        </p>
                        <pre class="tptp-code" style="background: #f8f9fa; padding: 15px; border-radius: 4px;">
h' = LayerNorm(ReLU(A · h · W))   # Per layer
clause_emb = pool(h, clause_mask)  # Pool node embeddings
score = MLP(clause_emb)            # Score each clause</pre>
                        <p class="rule-description">
                            <strong>Parameters:</strong> hidden_dim=64, num_layers=3, dropout=0.1
                        </p>
                    </div>

                    <div class="inference-rule">
                        <h4>Multi-Layer Perceptron (MLP)</h4>
                        <p>
                            A simpler baseline that pools node features directly without message passing:
                        </p>
                        <pre class="tptp-code" style="background: #f8f9fa; padding: 15px; border-radius: 4px;">
clause_emb = pool(node_features, clause_mask)
score = MLP(clause_emb)</pre>
                        <p class="rule-description">
                            Faster inference, useful for understanding the value of graph structure.
                        </p>
                    </div>

                    <div class="inference-rule">
                        <h4>Graph Attention Network (GAT)</h4>
                        <p>
                            Uses attention mechanisms to weight neighbor contributions:
                        </p>
                        <pre class="tptp-code" style="background: #f8f9fa; padding: 15px; border-radius: 4px;">
α_ij = softmax(LeakyReLU(a · [Wh_i || Wh_j]))
h'_i = Σ_j α_ij · Wh_j</pre>
                        <p class="rule-description">
                            <strong>Parameters:</strong> hidden_dim=64, num_layers=3, num_heads=4
                        </p>
                    </div>

                    <h3>Training</h3>

                    <div class="simplification-box">
                        <h4>Loss Function: InfoNCE (Contrastive)</h4>
                        <p>
                            We use contrastive learning to train the model to rank proof clauses higher than non-proof clauses:
                        </p>
                        <pre class="tptp-code" style="background: #f8f9fa; padding: 15px; border-radius: 4px; font-size: 14px;">
L = -log( exp(s_pos/τ) / (exp(s_pos/τ) + Σ exp(s_neg/τ)) )</pre>
                        <p>
                            For each positive clause (in proof), it should score higher than all negatives.
                            Temperature τ controls the sharpness of the distribution.
                        </p>
                    </div>

                    <div class="simplification-box">
                        <h4>Data Collection</h4>
                        <p>
                            Training data is collected by running the prover with a heuristic selector (age-weight):
                        </p>
                        <ul>
                            <li><strong>Positive labels:</strong> Clauses in the proof DAG (backward reachable from empty clause)</li>
                            <li><strong>Negative labels:</strong> Clauses generated but not used in the proof</li>
                        </ul>
                        <p class="note">
                            <strong>Note:</strong> This creates a learning-to-imitate setup. The model learns to predict
                            which clauses a successful proof search would select.
                        </p>
                    </div>

                    <h3>Inference Integration</h3>
                    <p>
                        During proof search, the trained model replaces the heuristic clause selector:
                    </p>

                    <div class="algorithm-box">
                        <h4>ML-Guided Selection</h4>
                        <ol>
                            <li>Convert all unprocessed clauses to graphs</li>
                            <li>Run GNN forward pass to get clause embeddings</li>
                            <li>Score each clause with the MLP head</li>
                            <li>Sample from softmax distribution over scores</li>
                            <li>Return selected clause as next given clause</li>
                        </ol>
                    </div>

                    <p class="note">
                        <strong>Performance:</strong> The Rust implementation uses the
                        <a href="https://burn.dev/">Burn</a> framework for efficient inference.
                        Embeddings are cached to avoid recomputation.
                    </p>

                    <h3>Quick Start</h3>
                    <pre class="tptp-code" style="background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 4px;">
# 1. Collect traces (runs prover, saves proof data)
proofatlas-bench --prover proofatlas --preset time_sel21

# 2. Train a GCN model
proofatlas-bench --prover proofatlas --preset gcn --force-train

# 3. Evaluate the trained model
proofatlas-bench --prover proofatlas --preset gcn

# 4. View training metrics
# Open training.html in browser</pre>

                    <p>
                        See <a href="./training.html">Training</a> for interactive visualization of training runs,
                        and <a href="./results.html">Results</a> for benchmark comparisons.
                    </p>
                </section>

                <section id="examples">
                    <h2>Examples</h2>

                    <div class="example-box">
                        <h3>Example 1: Simple Propositional Logic</h3>
                        <pre class="tptp-code">% If P implies Q, and Q implies R, then P implies R
fof(axiom1, axiom, p => q).
fof(axiom2, axiom, q => r).
fof(goal, conjecture, p => r).</pre>
                        <p class="example-result">
                            <strong>Result:</strong> Proof found in ~10ms using binary resolution
                        </p>
                    </div>

                    <div class="example-box">
                        <h3>Example 2: Equality Reasoning</h3>
                        <pre class="tptp-code">% Symmetry and transitivity imply that equality is an equivalence
fof(symmetry, axiom, ![X,Y]: (X = Y => Y = X)).
fof(transitivity, axiom, ![X,Y,Z]: ((X = Y & Y = Z) => X = Z)).
fof(goal, conjecture, ![A,B,C]: ((A = B & C = B) => A = C)).</pre>
                        <p class="example-result">
                            <strong>Result:</strong> Requires superposition to handle equality reasoning
                        </p>
                    </div>

                    <div class="example-box">
                        <h3>Example 3: Group Theory</h3>
                        <pre class="tptp-code">% Identity element exists
fof(left_identity, axiom, ![X]: mult(e, X) = X).
% Inverse exists
fof(left_inverse, axiom, ![X]: mult(inv(X), X) = e).
% Associativity
fof(associativity, axiom, ![X,Y,Z]:
    mult(X, mult(Y, Z)) = mult(mult(X, Y), Z)).
% Prove right identity
fof(right_identity, conjecture, ![X]: mult(X, e) = X).</pre>
                        <p class="example-result">
                            <strong>Result:</strong> Classic group theory proof using superposition and demodulation
                        </p>
                    </div>
                </section>

                <section id="references">
                    <h2>References</h2>
                    <ul>
                        <li>
                            Bachmair, L., & Ganzinger, H. (2001).
                            <em>Resolution Theorem Proving</em>.
                            Handbook of Automated Reasoning.
                        </li>
                        <li>
                            Nieuwenhuis, R., & Rubio, A. (2001).
                            <em>Paramodulation-Based Theorem Proving</em>.
                            Handbook of Automated Reasoning.
                        </li>
                        <li>
                            Schulz, S. (2013).
                            <em>System Description: E 1.8</em>.
                            LPAR 2013.
                        </li>
                    </ul>
                </section>
            </div>
        </main>

        <footer>
            <p>
                ProofAtlas - A saturation-based theorem prover |
                <a href="https://github.com/lexpk/proofatlas">GitHub</a>
            </p>
        </footer>
    </div>
</body>
</html>
