# Random Selector Proof Examples

This directory contains proof files generated by the BasicLoop with RandomSelector. Each proof demonstrates different aspects of random clause selection in theorem proving.

## Proof Files

### 1. `simple_random_proof.json`
- **Problem**: P(a), ~P(a)∨Q(a), ~Q(a) |- ⊥
- **Description**: Simple 3-clause problem demonstrating basic resolution chain
- **Steps**: 5
- **Key insight**: Even random selection quickly finds contradictions in small problems

### 2. `chain_random_proof.json`
- **Problem**: P(a) → Q(a) → R(a) → S(a), ~S(a) |- ⊥
- **Description**: Longer resolution chain requiring multiple steps
- **Steps**: 9
- **Key insight**: Random selection may not follow the optimal path but still finds the proof

### 3. `branching_random_proof.json`
- **Problem**: Multiple paths to contradiction
- **Description**: Problem with branching proof structure
- **Steps**: 6
- **Key insight**: Random selection explores one of several possible proof paths

### 4. `multi_path_seed_*.json`
- **Problem**: Same problem with different random seeds (111, 222, 333)
- **Description**: Demonstrates how different seeds lead to different proof paths
- **Steps**: Varies (5-6 steps)
- **Key insight**: Random selection produces different but valid proofs

### 5. `redundant_random_proof.json`
- **Problem**: Includes irrelevant clauses with different constants
- **Description**: Tests random selection with many irrelevant clauses
- **Steps**: 8
- **Key insight**: Random selection may explore irrelevant clauses, increasing proof length

### 6. `no_proof_random.json`
- **Problem**: Satisfiable clause set (no contradiction exists)
- **Description**: Horn clauses without negative unit clause
- **Steps**: 6 (exhausts possibilities)
- **Key insight**: Random selection exhausts all possibilities when no proof exists

### 7. `duplicate_literals_proof.json`
- **Problem**: Clauses with duplicate literals like P(a) ∨ P(a)
- **Description**: Tests handling of non-normalized clauses
- **Steps**: 4
- **Key insight**: System handles duplicate literals gracefully

### 8. `complex_random_proof.json`
- **Problem**: More complex problem with multiple predicates and constants
- **Description**: Attempts a more realistic problem (without unification)
- **Steps**: 8
- **Key insight**: Shows limitations when unification is needed

## Viewing Proofs

To inspect these proofs, use the provided scripts:

```bash
# Print proof in readable format
python scripts/print_proof.py tests/test_data/proofs/random_selector/simple_random_proof.json

# Interactive navigation
python scripts/inspect_proof.py tests/test_data/proofs/random_selector/simple_random_proof.json

# View summary only
python scripts/print_proof.py tests/test_data/proofs/random_selector/chain_random_proof.json --summary
```

## Key Observations

1. **Random selection is surprisingly effective** for small problems
2. **Different seeds produce different proofs** of varying lengths
3. **Redundant clauses increase proof length** but don't prevent finding proofs
4. **The system correctly handles edge cases** like duplicate literals and satisfiable problems

## Performance Comparison

Comparing the multi_path_seed proofs shows the variance in random selection:
- Seed 111: 6 steps
- Seed 222: 5 steps (found more direct path)
- Seed 333: 6 steps

This demonstrates that while random selection is non-deterministic in path choice, it reliably finds proofs when they exist.