"""Test that saves proofs generated by BasicLoop for inspection."""

import json
import unittest
from pathlib import Path

from proofatlas.core.logic import Predicate, Constant, Literal, Clause
from proofatlas.proofs import Proof
from proofatlas.proofs.state import ProofState
from proofatlas.proofs.serialization import ProofJSONEncoder
from proofatlas.loops.basic import BasicLoop


class TestBasicLoopSaveProofs(unittest.TestCase):
    """Test BasicLoop and save proofs for inspection."""
    
    def setUp(self):
        """Set up test data and output directory."""
        # Predicates and constants
        self.P = Predicate("P", 1)
        self.Q = Predicate("Q", 1)
        self.R = Predicate("R", 1)
        self.S = Predicate("S", 1)
        self.a = Constant("a")
        self.b = Constant("b")
        
        # Output directory - use new .data/proofs structure
        self.output_dir = Path(__file__).parent.parent.parent / ".data" / "proofs" / "test_examples" / "basic_loop"
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def save_proof(self, proof: Proof, filename: str, description: str = ""):
        """Save a proof to JSON file with description."""
        # Add metadata
        output = {
            "description": description,
            "generator": "BasicLoop",
            "proof": proof
        }
        
        filepath = self.output_dir / filename
        with open(filepath, 'w') as f:
            json.dump(output, f, cls=ProofJSONEncoder, indent=2)
        
        print(f"Saved proof to {filepath}")
    
    def test_simple_contradiction_proof(self):
        """Generate and save a simple contradiction proof."""
        loop = BasicLoop()
        
        # P(a) and ~P(a) leads to contradiction
        c1 = Clause(Literal(self.P(self.a), True))   # P(a)
        c2 = Clause(Literal(self.P(self.a), False))  # ~P(a)
        
        initial_state = ProofState(processed=[], unprocessed=[c1, c2])
        proof = Proof(initial_state=initial_state)
        
        # Step 1: Process P(a)
        proof = loop.step(proof, given_clause=0)
        
        # Step 2: Process ~P(a) - should generate empty clause
        proof = loop.step(proof, given_clause=0)
        
        # Check we found contradiction
        final_state = proof.final_state
        self.assertTrue(any(len(c.literals) == 0 for c in final_state.unprocessed))
        
        self.save_proof(
            proof, 
            "simple_contradiction.json",
            "Simple contradiction from P(a) and ~P(a)"
        )
    
    def test_modus_ponens_proof(self):
        """Generate and save a modus ponens proof."""
        loop = BasicLoop()
        
        # P(a), P(a) -> Q(a) |- Q(a)
        c1 = Clause(Literal(self.P(self.a), True))  # P(a)
        c2 = Clause(
            Literal(self.P(self.a), False),
            Literal(self.Q(self.a), True)
        )  # ~P(a) | Q(a) (i.e., P(a) -> Q(a))
        
        initial_state = ProofState(processed=[], unprocessed=[c1, c2])
        proof = Proof(initial_state=initial_state)
        
        # Step 1: Process P(a)
        proof = loop.step(proof, given_clause=0)
        
        # Step 2: Process ~P(a) | Q(a) - should generate Q(a)
        proof = loop.step(proof, given_clause=0)
        
        # Check we derived Q(a)
        final_state = proof.final_state
        self.assertTrue(any(
            len(c.literals) == 1 and 
            c.literals[0].predicate.symbol == self.Q and
            c.literals[0].polarity
            for c in final_state.unprocessed
        ))
        
        self.save_proof(
            proof,
            "modus_ponens.json", 
            "Modus ponens: P(a), P(a) -> Q(a) |- Q(a)"
        )
    
    def test_chain_resolution_proof(self):
        """Generate and save a chain resolution proof."""
        loop = BasicLoop()
        
        # P(a), P(a) -> Q(a), Q(a) -> R(a) |- R(a)
        c1 = Clause(Literal(self.P(self.a), True))  # P(a)
        c2 = Clause(
            Literal(self.P(self.a), False),
            Literal(self.Q(self.a), True)
        )  # ~P(a) | Q(a)
        c3 = Clause(
            Literal(self.Q(self.a), False),
            Literal(self.R(self.a), True)
        )  # ~Q(a) | R(a)
        
        initial_state = ProofState(processed=[], unprocessed=[c1, c2, c3])
        proof = Proof(initial_state=initial_state)
        
        # Process all clauses
        proof = loop.step(proof, given_clause=0)  # Process P(a)
        proof = loop.step(proof, given_clause=0)  # Process ~P(a) | Q(a), generates Q(a)
        proof = loop.step(proof, given_clause=0)  # Process ~Q(a) | R(a)
        proof = loop.step(proof, given_clause=0)  # Process Q(a), generates R(a)
        
        # Check we derived R(a)
        final_state = proof.final_state
        self.assertTrue(any(
            len(c.literals) == 1 and
            c.literals[0].predicate.symbol == self.R and
            c.literals[0].polarity
            for c in final_state.unprocessed
        ))
        
        self.save_proof(
            proof,
            "chain_resolution.json",
            "Chain resolution: P(a), P(a) -> Q(a), Q(a) -> R(a) |- R(a)"
        )
    
    def test_factoring_example_proof(self):
        """Generate and save a proof that uses factoring."""
        loop = BasicLoop()
        
        # Create clauses that will benefit from factoring
        # We need a more complex example for factoring
        # P(a) | P(a) | Q(a) and ~P(a) | ~Q(a) 
        c1 = Clause(
            Literal(self.P(self.a), True),
            Literal(self.P(self.a), True),
            Literal(self.Q(self.a), True)
        )  # P(a) | P(a) | Q(a) - can be factored to P(a) | Q(a)
        c2 = Clause(
            Literal(self.P(self.a), False),
            Literal(self.Q(self.a), False)
        )  # ~P(a) | ~Q(a)
        c3 = Clause(Literal(self.P(self.a), True))  # P(a)
        c4 = Clause(Literal(self.Q(self.a), True))  # Q(a)
        
        initial_state = ProofState(processed=[], unprocessed=[c1, c2, c3, c4])
        proof = Proof(initial_state=initial_state)
        
        # Process clauses - this demonstrates how factoring can simplify clauses
        for i in range(4):
            if proof.final_state.unprocessed:
                proof = loop.step(proof, given_clause=0)
        
        self.save_proof(
            proof,
            "factoring_example.json",
            "Example with factoring: P(a) | P(a) | Q(a), ~P(a) | ~Q(a), P(a), Q(a)"
        )
    
    def test_multiple_resolvents_proof(self):
        """Generate and save a proof where one step generates multiple resolvents."""
        loop = BasicLoop()
        
        # P(a) | Q(b), ~P(a) | ~Q(b) can resolve in two ways
        c1 = Clause(
            Literal(self.P(self.a), True),
            Literal(self.Q(self.b), True)
        )  # P(a) | Q(b)
        c2 = Clause(
            Literal(self.P(self.a), False),
            Literal(self.Q(self.b), False)
        )  # ~P(a) | ~Q(b)
        
        initial_state = ProofState(processed=[], unprocessed=[c1, c2])
        proof = Proof(initial_state=initial_state)
        
        # Process clauses
        proof = loop.step(proof, given_clause=0)  # Process P(a) | Q(b)
        proof = loop.step(proof, given_clause=0)  # Process ~P(a) | ~Q(b)
        
        # Should generate two resolvents: Q(b) | ~Q(b) and P(a) | ~P(a)
        # Both are tautologies if forward simplification is on
        
        self.save_proof(
            proof,
            "multiple_resolvents.json",
            "Example generating multiple resolvents: P(a) | Q(b), ~P(a) | ~Q(b)"
        )
    
    def test_larger_proof(self):
        """Generate and save a larger proof with multiple inference steps."""
        loop = BasicLoop()
        
        # More complex example: 
        # P(a), P(a) -> Q(a), Q(a) -> R(a), R(a) -> S(a), ~S(a) |- ⊥
        c1 = Clause(Literal(self.P(self.a), True))  # P(a)
        c2 = Clause(
            Literal(self.P(self.a), False),
            Literal(self.Q(self.a), True)
        )  # ~P(a) | Q(a)
        c3 = Clause(
            Literal(self.Q(self.a), False),
            Literal(self.R(self.a), True)
        )  # ~Q(a) | R(a)
        c4 = Clause(
            Literal(self.R(self.a), False),
            Literal(self.S(self.a), True)
        )  # ~R(a) | S(a)
        c5 = Clause(Literal(self.S(self.a), False))  # ~S(a)
        
        initial_state = ProofState(processed=[], unprocessed=[c1, c2, c3, c4, c5])
        proof = Proof(initial_state=initial_state)
        
        # Process until we find contradiction
        # This demonstrates the saturation process
        for i in range(10):  # Limit iterations
            if proof.final_state.unprocessed:
                # Check if we found contradiction
                if any(len(c.literals) == 0 for c in proof.final_state.unprocessed):
                    break
                proof = loop.step(proof, given_clause=0)
            else:
                break
        
        # Should find contradiction
        all_clauses = proof.final_state.processed + proof.final_state.unprocessed
        self.assertTrue(any(len(c.literals) == 0 for c in all_clauses))
        
        self.save_proof(
            proof,
            "larger_proof.json",
            "Larger proof: P(a), P(a)->Q(a), Q(a)->R(a), R(a)->S(a), ~S(a) |- ⊥"
        )


if __name__ == '__main__':
    unittest.main()